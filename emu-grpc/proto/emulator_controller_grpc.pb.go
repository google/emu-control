// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package android_emulator_control_proto

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EmulatorControllerClient is the client API for EmulatorController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EmulatorControllerClient interface {
	// set/get/stream the sensor data
	StreamSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (EmulatorController_StreamSensorClient, error)
	GetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*SensorValue, error)
	SetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*empty.Empty, error)
	// set/get/stream the physical model, this is likely the one you are
	// looking for when you wish to modify the device state.
	SetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*empty.Empty, error)
	GetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*PhysicalModelValue, error)
	StreamPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (EmulatorController_StreamPhysicalModelClient, error)
	// Atomically set/get the current primary clipboard data.
	SetClipboard(ctx context.Context, in *ClipData, opts ...grpc.CallOption) (*empty.Empty, error)
	GetClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ClipData, error)
	// Streams the current data on the clipboard. This will immediately produce
	// a result with the current state of the clipboard after which the stream
	// will block and wait until a new clip event is available from the guest.
	// Calling the setClipboard method above will not result in generating a clip
	// event. It is possible to lose clipboard events if the clipboard updates
	// very rapidly.
	StreamClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EmulatorController_StreamClipboardClient, error)
	// Set/get the battery to the given state.
	SetBattery(ctx context.Context, in *BatteryState, opts ...grpc.CallOption) (*empty.Empty, error)
	GetBattery(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BatteryState, error)
	// Set the state of the gps, gps support will only work
	// properly if:
	//
	// - no location ui is active. That is the emulator
	//   is launched in headless mode (-no-window) or the location
	//   ui is disabled (-no-location-ui).
	// - the passiveUpdate is set to false. Setting this to false
	//   will disable/break the LocationUI.
	//
	// Keep in mind that android usually only samples the gps at 1 hz.
	SetGps(ctx context.Context, in *GpsState, opts ...grpc.CallOption) (*empty.Empty, error)
	// Gets the latest gps state as delivered by the setGps call, or location ui
	// if active.
	//
	// Note: this is not necessarily the actual gps coordinate visible at the
	// time, due to gps sample frequency (usually 1hz).
	GetGps(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GpsState, error)
	// Simulate a touch event on the finger print sensor.
	SendFingerprint(ctx context.Context, in *Fingerprint, opts ...grpc.CallOption) (*empty.Empty, error)
	// Send a keyboard event. Translating the event.
	SendKey(ctx context.Context, in *KeyboardEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	// Send touch/mouse events. Note that mouse events can be simulated
	// by touch events.
	SendTouch(ctx context.Context, in *TouchEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	SendMouse(ctx context.Context, in *MouseEvent, opts ...grpc.CallOption) (*empty.Empty, error)
	// Make a phone call.
	SendPhone(ctx context.Context, in *PhoneCall, opts ...grpc.CallOption) (*PhoneResponse, error)
	// Sends an sms message to the emulator.
	SendSms(ctx context.Context, in *SmsMessage, opts ...grpc.CallOption) (*PhoneResponse, error)
	// Retrieve the status of the emulator. This will contain general
	// hardware information, and whether the device has booted or not.
	GetStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*EmulatorStatus, error)
	// Gets an individual screenshot in the desired format.
	//
	// The image will be scaled to the desired ImageFormat, while maintaining
	// the aspect ratio. The returned image will never exceed the provided width
	// and height. Not setting the width or height (i.e. they are 0) will result
	// in using the device width and height.
	//
	// The resulting image will be properly oriented and can be displayed
	// directly without post processing. For example, if the device has a
	// 1080x1920 screen and is in landscape mode and called with no width or
	// height parameter, it will return an 1920x1080 image.
	//
	// This method will return an empty image if the display is not visible.
	GetScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (*Image, error)
	// Streams a series of screenshots in the desired format.
	// A new frame will be delivered whenever the device produces a new frame.
	// (Beware that this can produce a significant amount of data, and that
	// certain translations are (png transform) can be costly).
	//
	// If the requested display is not visible it will send a single empty image
	// and wait start producing images once the display becomes active, again
	// producing a single empty image when the display becomes inactive.
	StreamScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (EmulatorController_StreamScreenshotClient, error)
	// Streams a series of audio packets in the desired format.
	// A new frame will be delivered whenever the emulated device
	// produces a new audio frame. You can expect packets to be
	// delivered in intervals of 20-30ms.
	//
	// Be aware that this can block when the emulator does not
	// produce any audio whatsoever!
	StreamAudio(ctx context.Context, in *AudioFormat, opts ...grpc.CallOption) (EmulatorController_StreamAudioClient, error)
	// Injects a series of audio packets to the android microphone.
	// A new frame will be delivered whenever the emulated device
	// requests a new audio frame. Audio is usually delivered at a rate
	// that the emulator is requesting frames. Audio will be stored in a
	// temporary buffer that can hold 500ms of audio.
	//
	// Note: Currently the emulator will downsample to 16khz.
	//
	// -  INVALID_ARGUMENT (code 3) The sampling rate was too high
	// -  INVALID_ARGUMENT (code 3) The audio packet was too large to handle.
	// -  FAILED_PRECONDITION (code 9) If there was a microphone registered already.
	InjectAudio(ctx context.Context, opts ...grpc.CallOption) (EmulatorController_InjectAudioClient, error)
	// Returns the last 128Kb of logcat output from the emulator
	// Note that parsed logcat messages are only available after L (Api >23).
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	GetLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (*LogMessage, error)
	// Streams the logcat output from the emulator. The first call
	// can retrieve up to 128Kb. This call will not return.
	// Note that parsed logcat messages are only available after L (Api >23)
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	StreamLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (EmulatorController_StreamLogcatClient, error)
	// Transition the virtual machine to the desired state. Note that
	// some states are only observable. For example you cannot transition
	// to the error state.
	SetVmState(ctx context.Context, in *VmRunState, opts ...grpc.CallOption) (*empty.Empty, error)
	// Gets the state of the virtual machine.
	GetVmState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VmRunState, error)
	// Atomically changes the current multi-display configuration.
	// After this call the given display configurations will be activated. You
	// can only update secondary displays. Displays with id 0 will be ignored.
	//
	// This call can result in the removal or addition of secondary displays, the final
	// display state can be observed by the returned configuration.
	//
	// The following gRPC error codes can be returned:
	// -  FAILED_PRECONDITION (code 9) if the AVD does not support a configurable
	//    secondary display.
	// -  INVALID_ARGUMENT (code 3) if:
	//     - The same display id is defined multiple times.
	//     - The display configurations are outside valid ranges
	//       (see DisplayConfiguration)
	// -  INTERNAL (code 13) if there was an internal emulator failure.
	SetDisplayConfigurations(ctx context.Context, in *DisplayConfigurations, opts ...grpc.CallOption) (*DisplayConfigurations, error)
	// Returns all currently valid logical displays.
	// The gRPC error code FAILED_PRECONDITION (code 9) is returned if the AVD
	// does not support a configurable secondary display.
	GetDisplayConfigurations(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*DisplayConfigurations, error)
	// Notifies client of the following changes:
	//
	// - Virtual scene camera status change.
	// - Display configuration changes from extended ui. This will only be fired
	//   if the user makes modifications the extended displays through the extended
	//   control tab.
	//
	// Note that this method will send the initial virtual scene state immediately.
	StreamNotification(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EmulatorController_StreamNotificationClient, error)
	// RotationRadian is relative to the camera's current orientation.
	RotateVirtualSceneCamera(ctx context.Context, in *RotationRadian, opts ...grpc.CallOption) (*empty.Empty, error)
	// Velocity is absolute
	SetVirtualSceneCameraVelocity(ctx context.Context, in *Velocity, opts ...grpc.CallOption) (*empty.Empty, error)
}

type emulatorControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewEmulatorControllerClient(cc grpc.ClientConnInterface) EmulatorControllerClient {
	return &emulatorControllerClient{cc}
}

func (c *emulatorControllerClient) StreamSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (EmulatorController_StreamSensorClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[0], "/android.emulation.control.EmulatorController/streamSensor", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamSensorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamSensorClient interface {
	Recv() (*SensorValue, error)
	grpc.ClientStream
}

type emulatorControllerStreamSensorClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamSensorClient) Recv() (*SensorValue, error) {
	m := new(SensorValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) GetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*SensorValue, error) {
	out := new(SensorValue)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getSensor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetSensor(ctx context.Context, in *SensorValue, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setSensor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setPhysicalModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (*PhysicalModelValue, error) {
	out := new(PhysicalModelValue)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getPhysicalModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamPhysicalModel(ctx context.Context, in *PhysicalModelValue, opts ...grpc.CallOption) (EmulatorController_StreamPhysicalModelClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[1], "/android.emulation.control.EmulatorController/streamPhysicalModel", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamPhysicalModelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamPhysicalModelClient interface {
	Recv() (*PhysicalModelValue, error)
	grpc.ClientStream
}

type emulatorControllerStreamPhysicalModelClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamPhysicalModelClient) Recv() (*PhysicalModelValue, error) {
	m := new(PhysicalModelValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) SetClipboard(ctx context.Context, in *ClipData, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setClipboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ClipData, error) {
	out := new(ClipData)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getClipboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamClipboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EmulatorController_StreamClipboardClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[2], "/android.emulation.control.EmulatorController/streamClipboard", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamClipboardClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamClipboardClient interface {
	Recv() (*ClipData, error)
	grpc.ClientStream
}

type emulatorControllerStreamClipboardClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamClipboardClient) Recv() (*ClipData, error) {
	m := new(ClipData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) SetBattery(ctx context.Context, in *BatteryState, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setBattery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetBattery(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BatteryState, error) {
	out := new(BatteryState)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getBattery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetGps(ctx context.Context, in *GpsState, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setGps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetGps(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GpsState, error) {
	out := new(GpsState)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getGps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendFingerprint(ctx context.Context, in *Fingerprint, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendFingerprint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendKey(ctx context.Context, in *KeyboardEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendTouch(ctx context.Context, in *TouchEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendTouch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendMouse(ctx context.Context, in *MouseEvent, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendMouse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendPhone(ctx context.Context, in *PhoneCall, opts ...grpc.CallOption) (*PhoneResponse, error) {
	out := new(PhoneResponse)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendPhone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SendSms(ctx context.Context, in *SmsMessage, opts ...grpc.CallOption) (*PhoneResponse, error) {
	out := new(PhoneResponse)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/sendSms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetStatus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*EmulatorStatus, error) {
	out := new(EmulatorStatus)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (*Image, error) {
	out := new(Image)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getScreenshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamScreenshot(ctx context.Context, in *ImageFormat, opts ...grpc.CallOption) (EmulatorController_StreamScreenshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[3], "/android.emulation.control.EmulatorController/streamScreenshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamScreenshotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamScreenshotClient interface {
	Recv() (*Image, error)
	grpc.ClientStream
}

type emulatorControllerStreamScreenshotClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamScreenshotClient) Recv() (*Image, error) {
	m := new(Image)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) StreamAudio(ctx context.Context, in *AudioFormat, opts ...grpc.CallOption) (EmulatorController_StreamAudioClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[4], "/android.emulation.control.EmulatorController/streamAudio", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamAudioClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamAudioClient interface {
	Recv() (*AudioPacket, error)
	grpc.ClientStream
}

type emulatorControllerStreamAudioClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamAudioClient) Recv() (*AudioPacket, error) {
	m := new(AudioPacket)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) InjectAudio(ctx context.Context, opts ...grpc.CallOption) (EmulatorController_InjectAudioClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[5], "/android.emulation.control.EmulatorController/injectAudio", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerInjectAudioClient{stream}
	return x, nil
}

type EmulatorController_InjectAudioClient interface {
	Send(*AudioPacket) error
	CloseAndRecv() (*empty.Empty, error)
	grpc.ClientStream
}

type emulatorControllerInjectAudioClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerInjectAudioClient) Send(m *AudioPacket) error {
	return x.ClientStream.SendMsg(m)
}

func (x *emulatorControllerInjectAudioClient) CloseAndRecv() (*empty.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) GetLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (*LogMessage, error) {
	out := new(LogMessage)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getLogcat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamLogcat(ctx context.Context, in *LogMessage, opts ...grpc.CallOption) (EmulatorController_StreamLogcatClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[6], "/android.emulation.control.EmulatorController/streamLogcat", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamLogcatClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamLogcatClient interface {
	Recv() (*LogMessage, error)
	grpc.ClientStream
}

type emulatorControllerStreamLogcatClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamLogcatClient) Recv() (*LogMessage, error) {
	m := new(LogMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) SetVmState(ctx context.Context, in *VmRunState, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setVmState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetVmState(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VmRunState, error) {
	out := new(VmRunState)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getVmState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetDisplayConfigurations(ctx context.Context, in *DisplayConfigurations, opts ...grpc.CallOption) (*DisplayConfigurations, error) {
	out := new(DisplayConfigurations)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setDisplayConfigurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) GetDisplayConfigurations(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*DisplayConfigurations, error) {
	out := new(DisplayConfigurations)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/getDisplayConfigurations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) StreamNotification(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (EmulatorController_StreamNotificationClient, error) {
	stream, err := c.cc.NewStream(ctx, &EmulatorController_ServiceDesc.Streams[7], "/android.emulation.control.EmulatorController/streamNotification", opts...)
	if err != nil {
		return nil, err
	}
	x := &emulatorControllerStreamNotificationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EmulatorController_StreamNotificationClient interface {
	Recv() (*Notification, error)
	grpc.ClientStream
}

type emulatorControllerStreamNotificationClient struct {
	grpc.ClientStream
}

func (x *emulatorControllerStreamNotificationClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *emulatorControllerClient) RotateVirtualSceneCamera(ctx context.Context, in *RotationRadian, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/rotateVirtualSceneCamera", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *emulatorControllerClient) SetVirtualSceneCameraVelocity(ctx context.Context, in *Velocity, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/android.emulation.control.EmulatorController/setVirtualSceneCameraVelocity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmulatorControllerServer is the server API for EmulatorController service.
// All implementations must embed UnimplementedEmulatorControllerServer
// for forward compatibility
type EmulatorControllerServer interface {
	// set/get/stream the sensor data
	StreamSensor(*SensorValue, EmulatorController_StreamSensorServer) error
	GetSensor(context.Context, *SensorValue) (*SensorValue, error)
	SetSensor(context.Context, *SensorValue) (*empty.Empty, error)
	// set/get/stream the physical model, this is likely the one you are
	// looking for when you wish to modify the device state.
	SetPhysicalModel(context.Context, *PhysicalModelValue) (*empty.Empty, error)
	GetPhysicalModel(context.Context, *PhysicalModelValue) (*PhysicalModelValue, error)
	StreamPhysicalModel(*PhysicalModelValue, EmulatorController_StreamPhysicalModelServer) error
	// Atomically set/get the current primary clipboard data.
	SetClipboard(context.Context, *ClipData) (*empty.Empty, error)
	GetClipboard(context.Context, *empty.Empty) (*ClipData, error)
	// Streams the current data on the clipboard. This will immediately produce
	// a result with the current state of the clipboard after which the stream
	// will block and wait until a new clip event is available from the guest.
	// Calling the setClipboard method above will not result in generating a clip
	// event. It is possible to lose clipboard events if the clipboard updates
	// very rapidly.
	StreamClipboard(*empty.Empty, EmulatorController_StreamClipboardServer) error
	// Set/get the battery to the given state.
	SetBattery(context.Context, *BatteryState) (*empty.Empty, error)
	GetBattery(context.Context, *empty.Empty) (*BatteryState, error)
	// Set the state of the gps, gps support will only work
	// properly if:
	//
	// - no location ui is active. That is the emulator
	//   is launched in headless mode (-no-window) or the location
	//   ui is disabled (-no-location-ui).
	// - the passiveUpdate is set to false. Setting this to false
	//   will disable/break the LocationUI.
	//
	// Keep in mind that android usually only samples the gps at 1 hz.
	SetGps(context.Context, *GpsState) (*empty.Empty, error)
	// Gets the latest gps state as delivered by the setGps call, or location ui
	// if active.
	//
	// Note: this is not necessarily the actual gps coordinate visible at the
	// time, due to gps sample frequency (usually 1hz).
	GetGps(context.Context, *empty.Empty) (*GpsState, error)
	// Simulate a touch event on the finger print sensor.
	SendFingerprint(context.Context, *Fingerprint) (*empty.Empty, error)
	// Send a keyboard event. Translating the event.
	SendKey(context.Context, *KeyboardEvent) (*empty.Empty, error)
	// Send touch/mouse events. Note that mouse events can be simulated
	// by touch events.
	SendTouch(context.Context, *TouchEvent) (*empty.Empty, error)
	SendMouse(context.Context, *MouseEvent) (*empty.Empty, error)
	// Make a phone call.
	SendPhone(context.Context, *PhoneCall) (*PhoneResponse, error)
	// Sends an sms message to the emulator.
	SendSms(context.Context, *SmsMessage) (*PhoneResponse, error)
	// Retrieve the status of the emulator. This will contain general
	// hardware information, and whether the device has booted or not.
	GetStatus(context.Context, *empty.Empty) (*EmulatorStatus, error)
	// Gets an individual screenshot in the desired format.
	//
	// The image will be scaled to the desired ImageFormat, while maintaining
	// the aspect ratio. The returned image will never exceed the provided width
	// and height. Not setting the width or height (i.e. they are 0) will result
	// in using the device width and height.
	//
	// The resulting image will be properly oriented and can be displayed
	// directly without post processing. For example, if the device has a
	// 1080x1920 screen and is in landscape mode and called with no width or
	// height parameter, it will return an 1920x1080 image.
	//
	// This method will return an empty image if the display is not visible.
	GetScreenshot(context.Context, *ImageFormat) (*Image, error)
	// Streams a series of screenshots in the desired format.
	// A new frame will be delivered whenever the device produces a new frame.
	// (Beware that this can produce a significant amount of data, and that
	// certain translations are (png transform) can be costly).
	//
	// If the requested display is not visible it will send a single empty image
	// and wait start producing images once the display becomes active, again
	// producing a single empty image when the display becomes inactive.
	StreamScreenshot(*ImageFormat, EmulatorController_StreamScreenshotServer) error
	// Streams a series of audio packets in the desired format.
	// A new frame will be delivered whenever the emulated device
	// produces a new audio frame. You can expect packets to be
	// delivered in intervals of 20-30ms.
	//
	// Be aware that this can block when the emulator does not
	// produce any audio whatsoever!
	StreamAudio(*AudioFormat, EmulatorController_StreamAudioServer) error
	// Injects a series of audio packets to the android microphone.
	// A new frame will be delivered whenever the emulated device
	// requests a new audio frame. Audio is usually delivered at a rate
	// that the emulator is requesting frames. Audio will be stored in a
	// temporary buffer that can hold 500ms of audio.
	//
	// Note: Currently the emulator will downsample to 16khz.
	//
	// -  INVALID_ARGUMENT (code 3) The sampling rate was too high
	// -  INVALID_ARGUMENT (code 3) The audio packet was too large to handle.
	// -  FAILED_PRECONDITION (code 9) If there was a microphone registered already.
	InjectAudio(EmulatorController_InjectAudioServer) error
	// Returns the last 128Kb of logcat output from the emulator
	// Note that parsed logcat messages are only available after L (Api >23).
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	GetLogcat(context.Context, *LogMessage) (*LogMessage, error)
	// Streams the logcat output from the emulator. The first call
	// can retrieve up to 128Kb. This call will not return.
	// Note that parsed logcat messages are only available after L (Api >23)
	// it is possible that the logcat buffer gets overwritten, or falls behind.
	StreamLogcat(*LogMessage, EmulatorController_StreamLogcatServer) error
	// Transition the virtual machine to the desired state. Note that
	// some states are only observable. For example you cannot transition
	// to the error state.
	SetVmState(context.Context, *VmRunState) (*empty.Empty, error)
	// Gets the state of the virtual machine.
	GetVmState(context.Context, *empty.Empty) (*VmRunState, error)
	// Atomically changes the current multi-display configuration.
	// After this call the given display configurations will be activated. You
	// can only update secondary displays. Displays with id 0 will be ignored.
	//
	// This call can result in the removal or addition of secondary displays, the final
	// display state can be observed by the returned configuration.
	//
	// The following gRPC error codes can be returned:
	// -  FAILED_PRECONDITION (code 9) if the AVD does not support a configurable
	//    secondary display.
	// -  INVALID_ARGUMENT (code 3) if:
	//     - The same display id is defined multiple times.
	//     - The display configurations are outside valid ranges
	//       (see DisplayConfiguration)
	// -  INTERNAL (code 13) if there was an internal emulator failure.
	SetDisplayConfigurations(context.Context, *DisplayConfigurations) (*DisplayConfigurations, error)
	// Returns all currently valid logical displays.
	// The gRPC error code FAILED_PRECONDITION (code 9) is returned if the AVD
	// does not support a configurable secondary display.
	GetDisplayConfigurations(context.Context, *empty.Empty) (*DisplayConfigurations, error)
	// Notifies client of the following changes:
	//
	// - Virtual scene camera status change.
	// - Display configuration changes from extended ui. This will only be fired
	//   if the user makes modifications the extended displays through the extended
	//   control tab.
	//
	// Note that this method will send the initial virtual scene state immediately.
	StreamNotification(*empty.Empty, EmulatorController_StreamNotificationServer) error
	// RotationRadian is relative to the camera's current orientation.
	RotateVirtualSceneCamera(context.Context, *RotationRadian) (*empty.Empty, error)
	// Velocity is absolute
	SetVirtualSceneCameraVelocity(context.Context, *Velocity) (*empty.Empty, error)
	mustEmbedUnimplementedEmulatorControllerServer()
}

// UnimplementedEmulatorControllerServer must be embedded to have forward compatible implementations.
type UnimplementedEmulatorControllerServer struct {
}

func (UnimplementedEmulatorControllerServer) StreamSensor(*SensorValue, EmulatorController_StreamSensorServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamSensor not implemented")
}
func (UnimplementedEmulatorControllerServer) GetSensor(context.Context, *SensorValue) (*SensorValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSensor not implemented")
}
func (UnimplementedEmulatorControllerServer) SetSensor(context.Context, *SensorValue) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSensor not implemented")
}
func (UnimplementedEmulatorControllerServer) SetPhysicalModel(context.Context, *PhysicalModelValue) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPhysicalModel not implemented")
}
func (UnimplementedEmulatorControllerServer) GetPhysicalModel(context.Context, *PhysicalModelValue) (*PhysicalModelValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPhysicalModel not implemented")
}
func (UnimplementedEmulatorControllerServer) StreamPhysicalModel(*PhysicalModelValue, EmulatorController_StreamPhysicalModelServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamPhysicalModel not implemented")
}
func (UnimplementedEmulatorControllerServer) SetClipboard(context.Context, *ClipData) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetClipboard not implemented")
}
func (UnimplementedEmulatorControllerServer) GetClipboard(context.Context, *empty.Empty) (*ClipData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClipboard not implemented")
}
func (UnimplementedEmulatorControllerServer) StreamClipboard(*empty.Empty, EmulatorController_StreamClipboardServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamClipboard not implemented")
}
func (UnimplementedEmulatorControllerServer) SetBattery(context.Context, *BatteryState) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBattery not implemented")
}
func (UnimplementedEmulatorControllerServer) GetBattery(context.Context, *empty.Empty) (*BatteryState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBattery not implemented")
}
func (UnimplementedEmulatorControllerServer) SetGps(context.Context, *GpsState) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGps not implemented")
}
func (UnimplementedEmulatorControllerServer) GetGps(context.Context, *empty.Empty) (*GpsState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGps not implemented")
}
func (UnimplementedEmulatorControllerServer) SendFingerprint(context.Context, *Fingerprint) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFingerprint not implemented")
}
func (UnimplementedEmulatorControllerServer) SendKey(context.Context, *KeyboardEvent) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendKey not implemented")
}
func (UnimplementedEmulatorControllerServer) SendTouch(context.Context, *TouchEvent) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTouch not implemented")
}
func (UnimplementedEmulatorControllerServer) SendMouse(context.Context, *MouseEvent) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMouse not implemented")
}
func (UnimplementedEmulatorControllerServer) SendPhone(context.Context, *PhoneCall) (*PhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPhone not implemented")
}
func (UnimplementedEmulatorControllerServer) SendSms(context.Context, *SmsMessage) (*PhoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSms not implemented")
}
func (UnimplementedEmulatorControllerServer) GetStatus(context.Context, *empty.Empty) (*EmulatorStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedEmulatorControllerServer) GetScreenshot(context.Context, *ImageFormat) (*Image, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScreenshot not implemented")
}
func (UnimplementedEmulatorControllerServer) StreamScreenshot(*ImageFormat, EmulatorController_StreamScreenshotServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamScreenshot not implemented")
}
func (UnimplementedEmulatorControllerServer) StreamAudio(*AudioFormat, EmulatorController_StreamAudioServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamAudio not implemented")
}
func (UnimplementedEmulatorControllerServer) InjectAudio(EmulatorController_InjectAudioServer) error {
	return status.Errorf(codes.Unimplemented, "method InjectAudio not implemented")
}
func (UnimplementedEmulatorControllerServer) GetLogcat(context.Context, *LogMessage) (*LogMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogcat not implemented")
}
func (UnimplementedEmulatorControllerServer) StreamLogcat(*LogMessage, EmulatorController_StreamLogcatServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamLogcat not implemented")
}
func (UnimplementedEmulatorControllerServer) SetVmState(context.Context, *VmRunState) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVmState not implemented")
}
func (UnimplementedEmulatorControllerServer) GetVmState(context.Context, *empty.Empty) (*VmRunState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVmState not implemented")
}
func (UnimplementedEmulatorControllerServer) SetDisplayConfigurations(context.Context, *DisplayConfigurations) (*DisplayConfigurations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDisplayConfigurations not implemented")
}
func (UnimplementedEmulatorControllerServer) GetDisplayConfigurations(context.Context, *empty.Empty) (*DisplayConfigurations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDisplayConfigurations not implemented")
}
func (UnimplementedEmulatorControllerServer) StreamNotification(*empty.Empty, EmulatorController_StreamNotificationServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamNotification not implemented")
}
func (UnimplementedEmulatorControllerServer) RotateVirtualSceneCamera(context.Context, *RotationRadian) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateVirtualSceneCamera not implemented")
}
func (UnimplementedEmulatorControllerServer) SetVirtualSceneCameraVelocity(context.Context, *Velocity) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVirtualSceneCameraVelocity not implemented")
}
func (UnimplementedEmulatorControllerServer) mustEmbedUnimplementedEmulatorControllerServer() {}

// UnsafeEmulatorControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmulatorControllerServer will
// result in compilation errors.
type UnsafeEmulatorControllerServer interface {
	mustEmbedUnimplementedEmulatorControllerServer()
}

func RegisterEmulatorControllerServer(s grpc.ServiceRegistrar, srv EmulatorControllerServer) {
	s.RegisterService(&EmulatorController_ServiceDesc, srv)
}

func _EmulatorController_StreamSensor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SensorValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamSensor(m, &emulatorControllerStreamSensorServer{stream})
}

type EmulatorController_StreamSensorServer interface {
	Send(*SensorValue) error
	grpc.ServerStream
}

type emulatorControllerStreamSensorServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamSensorServer) Send(m *SensorValue) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_GetSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getSensor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetSensor(ctx, req.(*SensorValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetSensor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetSensor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setSensor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetSensor(ctx, req.(*SensorValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetPhysicalModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhysicalModelValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetPhysicalModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setPhysicalModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetPhysicalModel(ctx, req.(*PhysicalModelValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetPhysicalModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhysicalModelValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetPhysicalModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getPhysicalModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetPhysicalModel(ctx, req.(*PhysicalModelValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamPhysicalModel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PhysicalModelValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamPhysicalModel(m, &emulatorControllerStreamPhysicalModelServer{stream})
}

type EmulatorController_StreamPhysicalModelServer interface {
	Send(*PhysicalModelValue) error
	grpc.ServerStream
}

type emulatorControllerStreamPhysicalModelServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamPhysicalModelServer) Send(m *PhysicalModelValue) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_SetClipboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClipData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetClipboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setClipboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetClipboard(ctx, req.(*ClipData))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetClipboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetClipboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getClipboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetClipboard(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamClipboard_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamClipboard(m, &emulatorControllerStreamClipboardServer{stream})
}

type EmulatorController_StreamClipboardServer interface {
	Send(*ClipData) error
	grpc.ServerStream
}

type emulatorControllerStreamClipboardServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamClipboardServer) Send(m *ClipData) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_SetBattery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatteryState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetBattery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setBattery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetBattery(ctx, req.(*BatteryState))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetBattery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetBattery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getBattery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetBattery(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetGps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GpsState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetGps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setGps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetGps(ctx, req.(*GpsState))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetGps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetGps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getGps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetGps(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendFingerprint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Fingerprint)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendFingerprint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/sendFingerprint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendFingerprint(ctx, req.(*Fingerprint))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyboardEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/sendKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendKey(ctx, req.(*KeyboardEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendTouch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TouchEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendTouch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/sendTouch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendTouch(ctx, req.(*TouchEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendMouse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MouseEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendMouse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/sendMouse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendMouse(ctx, req.(*MouseEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhoneCall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/sendPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendPhone(ctx, req.(*PhoneCall))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SendSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmsMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SendSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/sendSms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SendSms(ctx, req.(*SmsMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetStatus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetScreenshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImageFormat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetScreenshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getScreenshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetScreenshot(ctx, req.(*ImageFormat))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamScreenshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImageFormat)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamScreenshot(m, &emulatorControllerStreamScreenshotServer{stream})
}

type EmulatorController_StreamScreenshotServer interface {
	Send(*Image) error
	grpc.ServerStream
}

type emulatorControllerStreamScreenshotServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamScreenshotServer) Send(m *Image) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_StreamAudio_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AudioFormat)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamAudio(m, &emulatorControllerStreamAudioServer{stream})
}

type EmulatorController_StreamAudioServer interface {
	Send(*AudioPacket) error
	grpc.ServerStream
}

type emulatorControllerStreamAudioServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamAudioServer) Send(m *AudioPacket) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_InjectAudio_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EmulatorControllerServer).InjectAudio(&emulatorControllerInjectAudioServer{stream})
}

type EmulatorController_InjectAudioServer interface {
	SendAndClose(*empty.Empty) error
	Recv() (*AudioPacket, error)
	grpc.ServerStream
}

type emulatorControllerInjectAudioServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerInjectAudioServer) SendAndClose(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *emulatorControllerInjectAudioServer) Recv() (*AudioPacket, error) {
	m := new(AudioPacket)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EmulatorController_GetLogcat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetLogcat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getLogcat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetLogcat(ctx, req.(*LogMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamLogcat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamLogcat(m, &emulatorControllerStreamLogcatServer{stream})
}

type EmulatorController_StreamLogcatServer interface {
	Send(*LogMessage) error
	grpc.ServerStream
}

type emulatorControllerStreamLogcatServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamLogcatServer) Send(m *LogMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_SetVmState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VmRunState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetVmState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setVmState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetVmState(ctx, req.(*VmRunState))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetVmState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetVmState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getVmState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetVmState(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetDisplayConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisplayConfigurations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetDisplayConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setDisplayConfigurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetDisplayConfigurations(ctx, req.(*DisplayConfigurations))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_GetDisplayConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).GetDisplayConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/getDisplayConfigurations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).GetDisplayConfigurations(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_StreamNotification_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(empty.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EmulatorControllerServer).StreamNotification(m, &emulatorControllerStreamNotificationServer{stream})
}

type EmulatorController_StreamNotificationServer interface {
	Send(*Notification) error
	grpc.ServerStream
}

type emulatorControllerStreamNotificationServer struct {
	grpc.ServerStream
}

func (x *emulatorControllerStreamNotificationServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func _EmulatorController_RotateVirtualSceneCamera_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotationRadian)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).RotateVirtualSceneCamera(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/rotateVirtualSceneCamera",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).RotateVirtualSceneCamera(ctx, req.(*RotationRadian))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmulatorController_SetVirtualSceneCameraVelocity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Velocity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmulatorControllerServer).SetVirtualSceneCameraVelocity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/android.emulation.control.EmulatorController/setVirtualSceneCameraVelocity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmulatorControllerServer).SetVirtualSceneCameraVelocity(ctx, req.(*Velocity))
	}
	return interceptor(ctx, in, info, handler)
}

// EmulatorController_ServiceDesc is the grpc.ServiceDesc for EmulatorController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EmulatorController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "android.emulation.control.EmulatorController",
	HandlerType: (*EmulatorControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getSensor",
			Handler:    _EmulatorController_GetSensor_Handler,
		},
		{
			MethodName: "setSensor",
			Handler:    _EmulatorController_SetSensor_Handler,
		},
		{
			MethodName: "setPhysicalModel",
			Handler:    _EmulatorController_SetPhysicalModel_Handler,
		},
		{
			MethodName: "getPhysicalModel",
			Handler:    _EmulatorController_GetPhysicalModel_Handler,
		},
		{
			MethodName: "setClipboard",
			Handler:    _EmulatorController_SetClipboard_Handler,
		},
		{
			MethodName: "getClipboard",
			Handler:    _EmulatorController_GetClipboard_Handler,
		},
		{
			MethodName: "setBattery",
			Handler:    _EmulatorController_SetBattery_Handler,
		},
		{
			MethodName: "getBattery",
			Handler:    _EmulatorController_GetBattery_Handler,
		},
		{
			MethodName: "setGps",
			Handler:    _EmulatorController_SetGps_Handler,
		},
		{
			MethodName: "getGps",
			Handler:    _EmulatorController_GetGps_Handler,
		},
		{
			MethodName: "sendFingerprint",
			Handler:    _EmulatorController_SendFingerprint_Handler,
		},
		{
			MethodName: "sendKey",
			Handler:    _EmulatorController_SendKey_Handler,
		},
		{
			MethodName: "sendTouch",
			Handler:    _EmulatorController_SendTouch_Handler,
		},
		{
			MethodName: "sendMouse",
			Handler:    _EmulatorController_SendMouse_Handler,
		},
		{
			MethodName: "sendPhone",
			Handler:    _EmulatorController_SendPhone_Handler,
		},
		{
			MethodName: "sendSms",
			Handler:    _EmulatorController_SendSms_Handler,
		},
		{
			MethodName: "getStatus",
			Handler:    _EmulatorController_GetStatus_Handler,
		},
		{
			MethodName: "getScreenshot",
			Handler:    _EmulatorController_GetScreenshot_Handler,
		},
		{
			MethodName: "getLogcat",
			Handler:    _EmulatorController_GetLogcat_Handler,
		},
		{
			MethodName: "setVmState",
			Handler:    _EmulatorController_SetVmState_Handler,
		},
		{
			MethodName: "getVmState",
			Handler:    _EmulatorController_GetVmState_Handler,
		},
		{
			MethodName: "setDisplayConfigurations",
			Handler:    _EmulatorController_SetDisplayConfigurations_Handler,
		},
		{
			MethodName: "getDisplayConfigurations",
			Handler:    _EmulatorController_GetDisplayConfigurations_Handler,
		},
		{
			MethodName: "rotateVirtualSceneCamera",
			Handler:    _EmulatorController_RotateVirtualSceneCamera_Handler,
		},
		{
			MethodName: "setVirtualSceneCameraVelocity",
			Handler:    _EmulatorController_SetVirtualSceneCameraVelocity_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "streamSensor",
			Handler:       _EmulatorController_StreamSensor_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamPhysicalModel",
			Handler:       _EmulatorController_StreamPhysicalModel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamClipboard",
			Handler:       _EmulatorController_StreamClipboard_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamScreenshot",
			Handler:       _EmulatorController_StreamScreenshot_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamAudio",
			Handler:       _EmulatorController_StreamAudio_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "injectAudio",
			Handler:       _EmulatorController_InjectAudio_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "streamLogcat",
			Handler:       _EmulatorController_StreamLogcat_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "streamNotification",
			Handler:       _EmulatorController_StreamNotification_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "emulator_controller.proto",
}
